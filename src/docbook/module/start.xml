<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd" [
<!ENTITY % CustomDTD SYSTEM "../custom.dtd">
%CustomDTD; 
]>
<chapter id="start">
  <title>Getting Started</title>
  <para>
    This chapter tours around the core constructs of Netty with simple
    examples to let you get started with Netty easily.  You should be able to
    write a network application on top of Netty right away when you are at the
    end of this chapter.
  </para>
  <para>
    If you prefer the top-down approach in learning something, you might want
    to start from <xref linkend="architecture"/> and get back here.
  </para>
  
  <section>
    <title>Minimum Requirement</title>
    <para>
      The minimum requirements to run the examples which are introduced in
      this chapter are just two; the latest version of Netty release and JDK
      1.5 or above.  The latest version of Netty is available in
      <ulink url="&Downloads;">the project download page</ulink>.
      To get the right version of JDK, please refer to your preferred JDK
      vendor's web site.  
    </para>
    <para>
      Is that all?  To tell the truth, you should find these two are just
      enough to implement almost any type of protocols.  Otherwise, please
      feel free to <ulink url="&Community;">contact the Netty
      project team</ulink> and let us know what's missing.
    </para>
  </section>
  
  <section>
    <title>Writing a Discard Server</title>
    <para>
      The most simplistic protocol in the world is not 'Hello, World!' but 
      <ulink url="http://tools.ietf.org/html/rfc863">DISCARD</ulink>.  It's
      a protocol which discards any received data without any response.
    </para>
    <para>
      What you are supposed to do to implement the DISCARD protocol is to log
      the received data, and that's all.  Let's start straight from the handler
      implementation, which handles I/O events generated by Netty.
    </para>
    <programlisting>package org.jboss.netty.example.discard;

import org.jboss.netty.channel.&ChannelHandlerContext;;
import org.jboss.netty.channel.&ChannelPipelineCoverage;;
import org.jboss.netty.channel.&ExceptionEvent;;
import org.jboss.netty.channel.&MessageEvent;;
import org.jboss.netty.channel.&SimpleChannelHandler;;

@&ChannelPipelineCoverage;("all")<co id="example.discard.co1"/>
public class DiscardServerHandler extends &SimpleChannelHandler; {<co id="example.discard.co2"/>

    @Override
    public void messageReceived(&ChannelHandlerContext; ctx, &MessageEvent; e) {<co id="example.discard.co3"/>
    }

    @Override
    public void exceptionCaught(&ChannelHandlerContext; ctx, &ExceptionEvent; e) {<co id="example.discard.co4"/>
        e.getCause().printStackTrace();
        
        &Channel; ch = e.getChannel();
        ch.close();
    }
}</programlisting>
    <calloutlist>
      <callout arearefs="example.discard.co1">
        <para>
          &ChannelPipelineCoverage; annotates a handler type to tell if the
          handler instance of the annotated type can be shared by more than
          one &Channel; (and its associated &ChannelPipeline;).
          <classname>DiscardServerHandler</classname> doesn't manage any
          stateful information, and therefore it's annotated with the value
          <literal>"all"</literal>.  It's OK even if you are confused with
          this yet.  We will revisit it soon.
        </para>
      </callout>
      <callout arearefs="example.discard.co2">
        <para>
          <classname>DiscardServerHandler</classname> extends
          &SimpleChannelHandler;, which is an implementation of
          &ChannelUpstreamHandler;.  &SimpleChannelHandler; provides various
          event handler methods that you can override.  For now, it's just
          enough to extend &SimpleChannelHandler; rather than to implement
          handler interfaces.
        </para>
      </callout>
      <callout arearefs="example.discard.co3">
        <para>
          We override the <methodname>messageReceived</methodname> event
          handler method here.  This method is called with a &MessageEvent;,
          which contains the received data, whenever new data is received
          from a client.  In this example, we just ignore the received data
          by doing nothing to implement the DISCARD protocol.
        </para>
      </callout>
      <callout arearefs="example.discard.co4">
        <para>
          <methodname>exceptionCaught</methodname> event handler method is
          called with an &ExceptionEvent; when an exception was raised by
          Netty due to I/O error or by a handler implementation due to the
          exception thrown while processing events.  In most cases, the
          caught exception should be logged and its associated channel
          should be closed here, although the implementation of this method
          can be different depending on what you want to do to deal with an
          exceptional situation.  For example, you might want to send a
          response message with an error code before closing the connection.
        </para>
      </callout>
    </calloutlist>
    <para>
      So far so good.  We have implemented the half of the DISCARD server.
      What's left now is to write the <methodname>main</methodname> method
      which starts the server up with the <classname>DiscardServerHandler</classname>.
    </para>
    <programlisting>package org.jboss.netty.example.discard;

import java.net.InetSocketAddress;
import java.util.concurrent.Executors;

import org.jboss.netty.bootstrap.&ServerBootstrap;;
import org.jboss.netty.channel.&ChannelFactory;;
import org.jboss.netty.channel.socket.nio.&NioServerSocketChannelFactory;;

public class DiscardServer {

    public static void main(String[] args) throws Exception {
        &ChannelFactory;<co id="example.discard2.co1" /> factory =
            new &NioServerSocketChannelFactory;<co id="example.discard2.co2" />(
                    Executors.newCachedThreadPool(),
                    Executors.newCachedThreadPool());

        &ServerBootstrap; bootstrap = new &ServerBootstrap;<co id="example.discard2.co3" />(factory);

        DiscardServerHandler handler = new DiscardServerHandler();
        &ChannelPipeline; pipeline = bootstrap.getPipeline();
        pipeline.addLast("handler", handler);<co id="example.discard2.co4" />

        bootstrap.setOption("child.tcpNoDelay", true);<co id="example.discard2.co5" />
        bootstrap.setOption("child.keepAlive", true);

        bootstrap.bind(new InetSocketAddress(8080));<co id="example.discard2.co6" />
    }
}</programlisting>
    <calloutlist>
      <callout arearefs="example.discard2.co1">
        <para>
          &ChannelFactory; is a factory which creates a &Channel;
        </para>
      </callout>
      <callout arearefs="example.discard2.co2">
        <para>
        </para>
      </callout>
      <callout arearefs="example.discard2.co3">
        <para>
        </para>
      </callout>
      <callout arearefs="example.discard2.co4">
        <para>
        </para>
      </callout>
      <callout arearefs="example.discard2.co5">
        <para>
        </para>
      </callout>
      <callout arearefs="example.discard2.co6">
        <para>
        </para>
      </callout>
    </calloutlist>
  </section>
</chapter>
