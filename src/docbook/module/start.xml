<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd" [
<!ENTITY % CustomDTD SYSTEM "../custom.dtd">
%CustomDTD; 
]>
<chapter id="start">
  <title>Getting Started</title>
  <para>
    This chapter tours around the core constructs of Netty with simple
    examples to let you get started with Netty easily.  You should be able to
    write a network application on top of Netty right away when you are at the
    end of this chapter.
  </para>
  <para>
    If you prefer the top-down approach in learning something, you might want
    to start from <xref linkend="architecture"/> and get back here.
  </para>
  
  <section>
    <title>Minimum Requirement</title>
    <para>
      The minimum requirements to run the examples which are introduced in
      this chapter are just two; the latest version of Netty release and JDK
      1.5 or above.  The latest version of Netty is available in
      <ulink url="&home;/downloads.html">the project download page</ulink>.
      To get the right version of JDK, please refer to your preferred JDK
      vendor's web site.  
    </para>
    <para>
      Is that all?  To tell the truth, you should find these two are just
      enough to implement almost any type of protocols.  Otherwise, please
      feel free to <ulink url="&home;/community.html">contact the Netty
      project team</ulink> and let us know what's missing.
    </para>
  </section>
  
  <section>
    <title>Writing a Discard Server</title>
    <para>
      The most simplistic protocol in the world is not 'Hello, World!' but 
      <ulink url="http://tools.ietf.org/html/rfc863">DISCARD</ulink>.  It's
      a protocol which discards any received data without any response.
    </para>
    <para>
      What you are supposed to do to implement the DISCARD protocol is to log
      the received data, and that's all.  Let's start straight from the handler
      implementation, which handles I/O events generated by Netty.
    </para>
    <programlistingco>
      <areaspec>
        <area id="example.discard.c1" coords="9" />
        <area id="example.discard.c2" coords="10" />
        <area id="example.discard.c3" coords="13" />
        <area id="example.discard.c4" coords="17" />
      </areaspec>
      <programlisting>package org.jboss.netty.example.discard;

import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.ChannelPipelineCoverage;
import org.jboss.netty.channel.ExceptionEvent;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelHandler;

@<ulink url="&api;/org/jboss/netty/channel/ChannelPipelineCoverage.html">ChannelPipelineCoverage</ulink>("all")
public class DiscardServerHandler extends SimpleChannelHandler {

    @Override
    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) {
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) {
        e.getCause().printStackTrace();
        e.getChannel().close();
    }
}</programlisting>
      <calloutlist>
        <callout arearefs="example.discard.c1">
          <para>
            <ulink url="&api;/org/jboss/netty/channel/ChannelPipelineCoverage.html"><interfacename>ChannelPipelineCoverage</interfacename></ulink>
            annotates a handler type to tell if the handler instance of the
            annotated type can be shared by more than one
            <ulink url="&api;/org/jboss/netty/channel/Channel.html"><interfacename>Channel</interfacename></ulink>
            (and its associated <ulink url="&api;/org/jboss/netty/channel/ChannelPipeline.html"><interfacename>ChannelPipeline</interfacename></ulink>).
            <classname>DiscardServerHandler</classname> doesn't manage any
            stateful information, and therefore it's annotated with the value
            <literal>"all"</literal>.  It's OK even if you are confused with
            this yet.  We will revisit it soon. 
          </para>
        </callout>
        <callout arearefs="example.discard.c2">
          <para>
            <classname>DiscardServerHandler</classname> extends
            <ulink url="&api;/org/jboss/netty/channel/SimpleChannelHandler.html"><classname>SimpleChannelHandler</classname></ulink>,
            which is an implementation of
            <ulink url="&api;/org/jboss/netty/channel/ChannelUpstreamHandler.html"><interfacename>ChannelUpstreamHandler</interfacename></ulink>.
            <classname>SimpleChannelHandler</classname> provides various
            event handler methods that you can override.  For now, it's just
            enough to extend <classname>SimpleChannelHandler</classname>
            rather than to implement handler interfaces.
          </para>
        </callout>
        <callout arearefs="example.discard.c3">
          <para>
            We override the <methodname>messageReceived</methodname> event
            handler method here.  This method is called with a
            <ulink url="&api;/org/jboss/netty/channel/MessageEvent.html"><interfacename>MessageEvent</interfacename></ulink>,
            which contains the received data, whenever new data is received
            from a client.  In this example, we just ignore the received data
            by doing nothing to implement the DISCARD protocol.
          </para>
        </callout>
        <callout arearefs="example.discard.c4">
          <para>
            <methodname>exceptionCaught</methodname> event handler method is
            called with an
            <ulink url="&api;/org/jboss/netty/channel/ExceptionEvent.html"><interfacename>ExceptionEvent</interfacename></ulink>
            when an exception was raised by Netty due to I/O error or by
            a handler implementation due to the exception thrown while
            processing events.  In most cases, the caught exception should be
            logged and its associated channel should be closed here, although
            the implementation of this method can be different depending on
            what you want to do to deal with an exceptional situation.  For
            example, you might want to send a response message with an error
            code before closing the connection.
          </para>
        </callout>
      </calloutlist>
    </programlistingco>
    <para>
      So far so good.  We have implemented the half of the DISCARD server.
      What's left now is to write the <methodname>main</methodname> method
      which starts the server up with the <classname>DiscardServerHandler</classname>.
    </para>
    <programlistingco>
      <areaspec>
        <area id="example.discard2.c1" coords="13" />
        <area id="example.discard2.c2" coords="18" />
        <area id="example.discard2.c3" coords="21" />
        <area id="example.discard2.c4" coords="23" />
        <area id="example.discard2.c5" coords="26" />
      </areaspec>
      <programlisting>package org.jboss.netty.example.discard;

import java.net.InetSocketAddress;
import java.util.concurrent.Executors;

import org.jboss.netty.bootstrap.ServerBootstrap;
import org.jboss.netty.channel.ChannelFactory;
import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;

public class DiscardServer {

    public static void main(String[] args) throws Exception {
        ChannelFactory factory =
            new NioServerSocketChannelFactory(
                    Executors.newCachedThreadPool(),
                    Executors.newCachedThreadPool());

        ServerBootstrap bootstrap = new ServerBootstrap(factory);

        DiscardServerHandler handler = new DiscardServerHandler();
        bootstrap.getPipeline().addLast("handler", handler);

        bootstrap.setOption("child.tcpNoDelay", true);
        bootstrap.setOption("child.keepAlive", true);

        bootstrap.bind(new InetSocketAddress(8080));
    }
}</programlisting>
      <calloutlist>
        <callout arearefs="example.discard2.c1">
          <para>
            <ulink url="&api;/org/jboss/netty/channel/ChannelFactory.html"><interfacename>ChannelFactory</interfacename></ulink>
            is a factory which creates a <classname>Channel</classname>
          </para>
        </callout>
        <callout arearefs="example.discard2.c2">
          <para>
          </para>
        </callout>
        <callout arearefs="example.discard2.c3">
          <para>
          </para>
        </callout>
        <callout arearefs="example.discard2.c4">
          <para>
          </para>
        </callout>
        <callout arearefs="example.discard2.c5">
          <para>
          </para>
        </callout>
      </calloutlist>
    </programlistingco>
  </section>
</chapter>
